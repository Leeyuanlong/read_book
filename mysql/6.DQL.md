### DQL

- 查询

	- 1.查询大原则

		- 1）sql语句的时间花在哪了？
		   
			- 等待时间
			- 执行时间
			sql的优化，能够把控的只有这两部分

		- 2）sql语句的执行时间花在哪了？

			- 查找：沿着索引查找，慢者可能会全表扫描
			- 取出：查找到数据后，把数据取出来（sending data）

		- 3）如何查询快？

			- 1）查询快--->联合索引的顺序、区分度、长度
			- 2）取的快--->索引覆盖
			- 3）传输的少--->更少的行和列

				- 切分查询：按数据拆成多次
比如插入10000条数据，可以分拆每1000条为单位插入
联表查询时，按逻辑把表连接查询分成多个简单sql

		- 4）sql语句优化思路：不查--少查--高效的查

			- 1）不查：通过业务逻辑计算。有些数值不需要百分百精准，为提升少量精度造成系统开销不划算
			- 2）少查：尽量精准数据，少取行。比如有些新闻网站数据，一般一次性取列表的30条左右。
			- 3）高效的查：尽量走在索引上进行查询，最好走索引覆盖

	- 2.模糊查询
		- like
		- 如果建表的时候，指定的字符集不区分大小写，那么like操作也不会区分大小写，%aaa%也会检索出带有'AAA'的结果

避免这种情况的发生：select * from tb_name like binary "%aaa%";这样就不会再匹配"AAA"的结果了。
这种规避对于variables和status不起作用

	- 3.IN型子查询引出的陷阱

		- 1.MySQL的查询优化器，针对In型子查询做优化，被改成了exists的执行效果
		- 2.将外层表中的数据一条一条取出后带入子查询中检查。所以子查询效率很低
		- 3.解决办法：使用连接查询代替子查询

	- 4.from型子查询

		- 内层from语句查到的临时表，是没有索引的，所以from的返回内容要尽量少，需要排序，在内层先排好序

- 视图

	- create view view_name as select name,age from tb_name;

- 子查询

	- select * from tb_name where XXX in (select * from  tb_name where XXX)
